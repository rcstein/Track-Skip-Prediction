---
title: "Session_Analysis of Spotify Data"
author: "Becca Stein and Rice Tyler"
date: "12/11/2019"
output: html_document:
  theme: readable
---

The Spotify dataset is intended to train a model to predict song skips. However, the data on users' *sequence* of listening behavior, with song skips being only one channel of the sequence, is interesting to explore in itself, and may also lead to insights about the processes driving song skipping behavior (cite paper on sequential music listening behavior). Using sequential analysis and Mixture Hidden Markov Models, we can find similarities between listening sessions in their entirety, cluster them into groups, and examine those groups for shared characteristics (cite paper on sequence clustering with Markov Models). We can define time series data as sets of sequences in R using the TraMineR package, and fit HMMs to sequence data using the seqHMM package. 

TraMineR, seqHMM, and indeed sequence analysis in general, were designed for and have been primarily applied to sociological data such as life courses (marital status, residential status, etc.). (cite package docs). The assumption of the sociological domain is built into the packages to an extent: TraMineR requires start and end points to be specified for each sequence step, and accepts ages or calendar years as values (cite package docs). Thus, adapting it to listening session data required a bit of fudging, i.e., each session step is given an "age-range" from its position in the sequence to the next position in the sequence. For example, song 1 has a start point of 1 and an endpoint of 2. 

Various researchers have studied sequential patterns in music session listening behavior using other methods (cite music sequence paper), but to the best of our knowledge this is the first application of Hidden Markov Models and the associated R packages to the problem. 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
 # code for converting data to SPELL format for TraMineR and seqHMM #
# play_data <- read.csv("~/Documents/MSDS/Data Mining/Spotify Track Skips//training_set/spotify-data-train.csv", nrows = 400000,stringsAsFactors = FALSE)
# track_data <- read.csv("~/Documents/MSDS/Data Mining/Spotify Track Skips/track_features/tf-1.csv") %>% bind_rows(read.csv("~/Documents/MSDS/Data Mining/Spotify Track Skips/track_features/tf-2.csv"))
# 
# score <- function(x) { # Convert continuous vars to discrete "scores" for sequence modeling
#           return(factor(round(x *10)))
# }
# Sequence_Train <- filter(Train, session_length == 20) %>% select(session_id, session_position, skip_1, skip_2, skip_3, context_type, hist_user_behavior_n_seekfwd, hist_user_behavior_n_seekback, hist_user_behavior_is_shuffle, hist_user_behavior_reason_end, hist_user_behavior_reason_start, us_popularity_estimate, release_year, beat_strength, bounciness, danceability, dyn_range_mean, energy, flatness, instrumentalness, liveness, loudness, mechanism, organism, speechiness, tempo, valence, date) %>% slice(1:400000)
# 
# Sequence_Train$release_year <- ifelse(Sequence_Train$release_year%%10 == 0, Sequence_Train$release_year, Sequence_Train$release_year - (Sequence_Train$release_year%%10)) #convert release years to decades
# Sequence_Train$release_year <- factor(Sequence_Train$release_year)
# Sequence_Train <- mutate_if(Sequence_Train, is.numeric, funs(score(.)))
# Sequence_Train$session_position <- as.integer(Sequence_Train$session_position) 
# Sequence_Train <- mutate(Sequence_Train, play_time = (ifelse(skip_1 == 1, "short", ifelse(skip_2 == 1, "med",
#                                                             ifelse(skip_3 == 1,"long", "full")))))
# Sequence_Train$end <- Sequence_Train$session_position + 1
# play_time_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 2, status = 29)
# context_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 6, process = F)
# year_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 13, process = F)
# dance_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 16, process = F)
# beat_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 14, process = F)
# bounce_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 15, process = F)
# energy_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 18, process = F)
# flat_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 19, process = F)
# inst_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 20, process = F)
# live_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 21, process = F)
# loud_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 22, process = F)
# speech_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 25, process = F)
# temp_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 26, process = F)
# val_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 27, process = F)
# seekfwd_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 7, process = F)
# seekbk_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 8, process = F)
# start_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 11, process = F)
# end_seq <- seqformat(Sequence_Train, from = "SPELL", to = "STS", id = 1, begin = 2, end = 30, status = 10, process = F)
# 
# sequences <- list(play_time_seq, context_seq, year_seq, dance_seq, beat_seq, bounce_seq, energy_seq, flat_seq, inst_seq,
#                   live_seq, loud_seq, speech_seq, temp_seq, val_seq, seekfwd_seq, seekbk_seq, start_seq, end_seq)
# sequence_names <-  c("skip", "context", "year", "dance", "beat", "bounce", "energy", "flat", "inst", "live","loud", "speech","temp",
#                      "val", "seekfwd", "seekbk", "start", "end")
# dates <- distinct(Sequence_Train,session_id,.keep_all = T) %>% select(session_id, date)
# for (s in 1:18) {
#   file_name <- str_c(sequence_names[s], "sequences.csv", sep = "_")
#   sequences[[s]] <- rownames_to_column(sequences[[s]],var = "index")
#   s <- left_join(sequences[[s]], dates, by = c("index" = "session_id"))[-22]
#   write.csv(s,file_name)
# }

```


```{r, include=FALSE}
library(tidyr)
library(seqHMM)
library(TraMineR)
library(RColorBrewer)
library(colorspace)
skip <- read.csv("skip_sequences.csv", row.names = 1)
context <- read.csv("context_sequences.csv", row.names = 1)
year <- read.csv("year_sequences.csv", row.names = 1)
dance <- read.csv("dance_sequences.csv", row.names = 1)
beat <- read.csv("beat_sequences.csv", row.names = 1)
bounce <-read.csv("bounce_sequences.csv", row.names = 1)
energy <- read.csv("energy_sequences.csv", row.names = 1)
flat <- read.csv("flat_sequences.csv", row.names = 1)
inst <- read.csv("inst_sequences.csv", row.names = 1)
live <- read.csv("live_sequences.csv", row.names = 1)
loud <- read.csv("loud_sequences.csv", row.names = 1)
speech <- read.csv("speech_sequences.csv", row.names = 1)
temp <- read.csv("temp_sequences.csv", row.names = 1)
val <- read.csv("val_sequences.csv", row.names = 1)
seekfwd <- read.csv("seekfwd_sequences.csv", row.names = 1)
seekbk <- read.csv("seekbk_sequences.csv", row.names = 1)
start <- read.csv("start_sequences.csv", row.names = 1)
end <- read.csv("end_sequences.csv", row.names = 1)
```

In total, we created 18 sequence objects, each representing one channel of user behavior: e.g. song dance-ability and tempo; song release decade, etc. Below is the code used to create one sequence object for the ways users ended songs:

Note that end_sequences.csv was pre-processed using the seqformat() function to convert the data from SPELL format to the STS format that TraMineR expects. SPELL format uses multiple rows for every obsservation, where each row is a step in that observation's sequence. STS format has one row per observation and represents each step as a column attribute. TraMineR and seqHMM are also specific to discrete state sequences. Continuous variables representing acoustic track features, such as "beat-strength", "energy", and "dance-ability" were converted to discrete scores by first normalizing them, then multiplying by 10 and rounding to the nearest integer. Finally, we converted release years to release decades to reduce the number of states and enhance visual interpretability of the plots. 

```{r}
end <- read.csv("end_sequences.csv", row.names = 1)
end_sequence <- seqdef(end, var = 2:21)
```


```{r, include=FALSE}
skip_sequence <- seqdef(skip, var = 2:21, alphabet = c("short", "med", "long", "full"), cpal = c("firebrick2","darkorange1", "gold1", "forestgreen"))
decade_sequence <- seqdef(year, var = 2:21, cpal = sequential_hcl(7,"SunsetDark"))
dance_sequence <- seqdef(dance, var = 2:21, cpal = diverge_hcl(61,"Blue-Red"))
beat_sequence <- seqdef(beat, var = 2:21, cpal = diverge_hcl(62,"Blue-Red"))
bounce_sequence <- seqdef(bounce, var = 2:21, cpal = diverge_hcl(55,"Blue-Red"))
start_sequence <- seqdef(start, var = 2:21, cpal = colorpalette[[10]])
energy_sequence <- seqdef(energy, var = 2:21, cpal =  diverge_hcl(56,"Blue-Red"))
#flat_sequence <- seqdef(flat, var = 2:21, cpal =  diverge_hcl(109,"Blue-Red"))
inst_sequence <- seqdef(inst, var = 2:21, cpal =  diverge_hcl(72,"Blue-Red"))
live_sequence <- seqdef(live, var = 2:21, cpal =  diverge_hcl(68,"Blue-Red"))
#loud_sequence <- seqdef(loud, var = 2:21, cpal =  diverge_hcl(196,"Blue-Red"))
seekbk_sequence <- seqdef(seekbk, var = 2:21, cpal = sequential_hcl(30,"SunsetDark"))
seekfwd_sequence <- seqdef(seekfwd, var = 2:21, cpal = sequential_hcl(30,"SunsetDark"))
speech_sequence <- seqdef(speech, var = 2:21, cpal =  diverge_hcl(73,"Blue-Red"))
temp_sequence <- seqdef(temp, var = 2:21, cpal =  diverge_hcl(66,"Blue-Red"))
val_sequence <- seqdef(val, var = 2:21, cpal =  diverge_hcl(45,"Blue-Red"))
```

TraMineR sequence objects have built-in plotting methods. We can plot the distribution of states in each sequence step, a selected sample of sequences, or the frequency of the most common sequency. The frequency plots have limited value for long sequences with many possible states, as the high variation means very few sequences will be identical, so the most common sequences may still be quite rare. 

Below are plots of 200 sequences for a selection of state channels. 
```{r, fig.height = 7, fig.width=5}
# Plots
plot_ub1 <- ssp(list(skip_sequence[200:400,], start_sequence[200:400,],end_sequence[200:400,]),
sortv = "from.start", sort.channel = 1, type = "I",
ylab = c("Song Play Time", "Song Start", "Song End"),
xtlab = 1:20, xlab = "Session Position", title = "200 User Behavior Sequences",
title.n = FALSE, legend.prop = 0.4, ylab.pos = c(2, 2,2), cex.legend = .8,
ncol.legend = c(1, 2,2))

plot_ub2 <- ssp(list(skip_sequence[200:400,], start_sequence[200:400,],end_sequence[200:400,]),
sortv = "from.start", sort.channel = 1, type = "d",
ylab = c("Song Play Time", "Song Start", "Song End"),
xtlab = 1:20, xlab = "Session Position", title = "User Behavior Distributions",
title.n = FALSE, legend.prop = 0.4, ylab.pos = c(2, 2,2), cex.legend = .8,
ncol.legend = c(1, 2,2), border = NA)

plot_track1 <- ssp(list(decade_sequence[200:400,], dance_sequence[200:400,],beat_sequence[200:400,]),
sortv = "from.start", sort.channel = 2, type = "I",
ylab = c("Decade", "Dance-iness", "Beat Strength"),
xtlab = 1:20, xlab = "Session Position", title = "200 Track Feature Sequences",
title.n = FALSE, legend.prop = 0.4, ylab.pos = c(2, 2,2), cex.legend = .8,
ncol.legend = c(1, 6,6))

plot_track2 <- ssp(list(energy_sequence[200:400,], live_sequence[200:400,],inst_sequence[200:400,]),
sortv = "from.start", sort.channel = 1, type = "I",
ylab = c("Energy", "Liveness", "Instrumentalness"),
xtlab = 1:20, xlab = "Session Position", title = "200 Track Feature Sequences",
title.n = FALSE, legend.prop = 0.4, ylab.pos = c(2, 2,2), cex.legend = .8,
ncol.legend = c(6, 6,6))

plot_track3 <- ssp(list(speech_sequence[200:400,], temp_sequence[200:400,],val_sequence[200:400,]),
sortv = "from.start", sort.channel = 1, type = "I",
ylab = c("Speechiness", "Tempo", "Valence"),
xtlab = 1:20, xlab = "Session Position", title = "200 Track Feature Sequences",
title.n = FALSE, legend.prop = 0.4, ylab.pos = c(2, 2,2), cex.legend = .8,
ncol.legend = c(6, 6,6))

plot_track4 <- ssp(list(dance_sequence[200:400,],beat_sequence[200:400,],energy_sequence[200:400,], live_sequence[200:400,],inst_sequence[200:400,],speech_sequence[200:400,], temp_sequence[200:400,],val_sequence[200:400,]),
sortv = "from.start", sort.channel = 1, type = "d",
ylab = c("Dnc", "Beat", "En", "Live", "Instr", "Speech", "Temp", "Val"),
xtlab = 1:20, xlab = "Session Position", title = "Track Feature Distributions",
title.n = FALSE, legend.prop = .1, ylab.pos = c(2, 1,2,1,2,1,2,1), cex.legend = .1,
ncol.legend = c(6,6,6,6,6,6,6,6),border = NA)
class(plot_ub1)
seq_plots <- list(plot_ub1,plot_ub2, plot_track1, plot_track2, plot_track3, plot_track4)

gridplot(seq_plots[1:2], byrow = T,with.legend = "FALSE",legend.pos = "right")

gridplot(seq_plots[3:5], nrow = 2, ncol =2, with.legend = F)

```


```{r}

```


Future projects could include expansions of TraMineR and seqHMM to acoomodate continuous data and generalize more ready to domains outside of sociology. 